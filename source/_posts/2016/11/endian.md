---
title: 数据存储方式 - endian
date: 2016-11-23 00:00:00
categories: 其它技术话题
tags:
  - Binary
  - Endian
---
现有两大CPU派系PowerPC以及Intel在数据存储上存在着差异，二者分别采用了big-endian以及little-endian方式保存一个多字节的数字。原本我从来没关注过这个问题，现有的工具已经把它们的差异封装得很好了，直到我最近尝试去操作了一些二进制数据才意识到我需要关注一下。
<!-- more -->
数据在内存中是以二进制方式存储的，一个字节可以存储一个8位的整型，有符号整型可以存储-128至127，而无符号整型可以存储0-255。无符号整型255写成二进制以及十六进制形式是：

1111 1111
F    F

也就是范围用16进制表示是0x00至0xff，我们后边就用两个16进制的字符来表示一个字节的值。

网上有篇文章讲解endian，使用了0x12345678作为例子，我觉得非常好，事实上我也是参考了那篇文章，并把自己的理解写在这。这个数字是8个16进制字符，按2个字符1个字节算其实它就是一个32位的无符号整型，即4个字节，按照我们的书写习惯它应该是这么写的：

![big-endian](/images/2016/11/endian-1.png)

这种写法被称为big-endian，它的存储原则是高位优先，从高位字节到低位字节按顺序写到相邻的四个字节中，PowerPC采用的正是这种方式。

Intel采用是little-endian，它的存储原则是低位优先，从低位字节到高拉字节按顺序写到相邻的四个字节中，也就是big-endian反过来：

![little-endian](/images/2016/11/endian-2.png)

二者到底有什么优缺点呢？

* big-endian相对来说更符合人类阅读习惯
* big-endian在判断数字的正负上比较有优势，只要取第一个字节的一个位的值就可以判断。
* little-endian在数据类型转换上比较有优势，因为同一个数字在不同位数的数据类型中排列完全相同。

关于类型转换我们试着用一个无符号整型10（二进制为1010）在8位、16位、32位整型中的存储方式说明:
* big-endian

&nbsp;&nbsp;8位 0000 1010  
16位 0000 0000 0000 1010  
32位 0000 0000 0000 0000 0000 0000 0000 1010

* little-endian

&nbsp;&nbsp;8位 0000 0101  
16位 0000 1010 0000 0000  
32位 0000 1010 0000 0000 0000 0000 0000 0000

从示例中可以看出，如果使用little-endian保存数据，32位的10转成16位的10需要从左到右复制16位，转成8位则是复制8位，后边直接截断不管了，极其方便。而big-endian方式则需要移动位游标再进行复制，性能上是little-endian更高。

需要提一下的是，网络上传输数据时一率采用big-endian进行传输，这是为了防止数据源跟数据接收端使用的存储方式不同而导致发生数据错乱。
